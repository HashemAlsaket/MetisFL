syntax = "proto3";
package metisfl;

///////////////////////////
// Tensor Representation //
///////////////////////////

/**
 * Aiming for a minimal representation based on the numpy.dtype Python class.
 * See https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html
 * Following representation is based on the excellent work of Max Klein:
 * https://github.com/telamonian/numpy-protobuf
 */
message DType {

  enum Type {
    INT8 = 0; // Byte (-128 to 127)
    INT16 = 1; // Integer (-32768 to 32767)
    INT32 = 2; // Integer (-2147483648 to 2147483647)
    INT64 = 3; // Integer (-9223372036854775808 to 9223372036854775807)
    UINT8 = 4; // Unsigned integer (0 to 255)
    UINT16 = 5; // Unsigned integer (0 to 65535)
    UINT32 = 6; // Unsigned integer (0 to 4294967295)
    UINT64 = 7; // Unsigned integer (0 to 18446744073709551615)
    FLOAT32 = 8; // Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
    FLOAT64 = 9; // Double precision float: sign bit, 11 bits exponent, 52 bits mantissa
  }

  enum ByteOrder {
    NA = 0; // Order not applicable. For example, endian is not relevant for 8 bit numbers, e.g., int8, uint8!
    BIG_ENDIAN_ORDER = 1; // We add the _ORDER suffix because the BIG_ENDIAN and LITTLE_ENDIAN macros are already used.
    LITTLE_ENDIAN_ORDER = 2;
  }

  Type type = 1;
  ByteOrder byte_order = 2;
  bool fortran_order = 3;

}

message TensorQuantifier {
  optional uint32 tensor_non_zeros = 1; // We set the field as optional because we want to print/record the zero values.
  optional uint32 tensor_zeros = 2; // We set the field as optional because we want to print/record the zero values.
  uint32 tensor_size_bytes = 3;
}


message Tensor {
  bool encrypted = 1;
  uint32 length = 2;
  repeated int64 dimensions = 3;
  DType type = 4;
  bytes value = 5;
}

message Model {
  repeated Tensor tensors = 1;
}