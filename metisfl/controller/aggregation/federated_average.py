#!/usr/bin/python3
import numpy as np
import struct
from typing import List

from google.protobuf.text_format import Parse
from metisfl.proto.model_pb2 import Model, Tensor, TensorQuantifier

class FederatedAverage:
    """
    Compute average of predictions generated by federated models.
    """
    def __init__(self):
        self.model = Model()

    def Aggregate(self, pairs):

        sample_model = pairs[0][0][0]

        self.model.tensors.CopyFrom(sample_model.tensors)

        total_tensors = self.model.tensors_size()

        for var_idx in range(total_tensors):
            var_num_values = self.model.tensors[var_idx].length()

            aggregated_tensor = self.AggregateTensorAtIndex(pairs, var_idx, var_num_values)
            serialized_tensor = TensorOps.serialize_tensor(aggregated_tensor)
            serialized_tensor_str = serialized_tensor.tostring()

            self.model.tensors[var_idx].value = serialized_tensor_str

        return self.model

    def Reset(self):
        pass

    def AddTensors(self, tensor_left, tensor_spec_right, scaling_factor_right):
        t2_r = np.fromstring(tensor_spec_right.value, dtype=float)
        t2_r *= scaling_factor_right

        tensor_left += t2_r

    def AggregateTensorAtIndex(self, pairs, var_idx, var_num_values):
        aggregated_tensor = np.zeros(var_num_values)

        for pair in pairs:
            local_model = pair[0][0]

            if not local_model.encrypted:
                local_tensor = local_model.tensors[var_idx]
                self.AddTensors(aggregated_tensor, local_tensor, pair[0][1])
            else:
                raise RuntimeError("Cannot aggregate encrypted tensors using Federated Average.")
        
        return aggregated_tensor


class TensorOps:
    """
    Generic tensor operations.
    """
    @staticmethod
    def deserialize_tensor(tensor: Tensor) -> List[float]:
        tensor_bytes = tensor.value
        tensor_elements_num = tensor.length
        deserialized_tensor = struct.unpack(f'{tensor_elements_num}d', tensor_bytes)
        return list(deserialized_tensor)

    @staticmethod
    def serialize_tensor(v: List[float]) -> bytes:
        serialized_tensor = struct.pack(f'{len(v)}d', *v)
        return serialized_tensor

    @staticmethod
    def quantify_tensor(tensor: Tensor) -> TensorQuantifier:
        t = TensorOps.deserialize_tensor(tensor)
        t_zeros = t.count(0)
        t_non_zeros = len(t) - t_zeros
        t_bytes = struct.calcsize('d') * len(t)

        tensor_quantifier = TensorQuantifier()
        tensor_quantifier.tensor_non_zeros = t_non_zeros
        tensor_quantifier.tensor_zeros = t_zeros
        tensor_quantifier.tensor_size_bytes = t_bytes

        return tensor_quantifier

    @staticmethod
    def print_serialized_tensor(data: bytes, num_values: int) -> None:
        loaded_values = struct.unpack(f'{num_values}d', data)
        print(', '.join(map(str, loaded_values)))

    @staticmethod
    def parse_text_or_die(input_str: str, message_type):
        result = message_type()
        Parse(input_str, result)
        return result
